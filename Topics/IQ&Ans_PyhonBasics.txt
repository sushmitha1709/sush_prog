1.Explain split() and join() functions in Python?
	You can use split() function to split a string based on a delimiter to a list of strings.
	You can use join() function to join a list of strings based on a delimiter to give a single string.
	string = "This is a string."
	string_list = string.split(' ') #delimiter is ‘space’ character or ‘ ‘
	print(string_list) #output: ['This', 'is', 'a', 'string.']
	print(' '.join(string_list)) #output: This is a string

2.What does *args and **kwargs mean?
*args:
	*args is uesd to pass multiple arguments to a function.
	Datatype of args is tuple. (OR)
	If you do not know how many arguments that will be passed into your function, add a * before the parameter name in the function definition.
	This way the function will receive a tuple of arguments, and can access the items accordingly:
	
Ex:	def multiply(a, b, *argv):
   		mul = a * b
   		for num in argv:
       			mul *= num
   		return mul
	print(multiply(1, 2, 3, 4, 5)) #output: 120

**kwargs:
	**kwargs works just like *args, but instead of accepting positional arguments it accepts keyword (or named) arguments.
	we want to pass keyword arguments, which are basically key-value pairs as arguments to a function.

Ex:
	def country_details(**state_info):
    		for key, value in state_info.items():
        		print("{} : {}".format(key, value))
    		print('\n\n')
	country_details(StateName="Telangana", Capital="Hyderabad", Population=3400000)
o/p:
	StateName : Telangana
	Capital : Hyderabad
	Population : 3400000

What is the difference between *ARGs and **kwargs in Python?
	While *args can accept any number of positional arguments, Python **kwargs can accept any number of named arguments. 
	You can use *args and **kwargs in a function definition to accept both positional arguments and named arguments, whose count is unknown.

3.What are negative indexes and why are they used?
	Negative indexes are the indexes from the end of the list or tuple or string.
	(OR)Negative indexes are used to find the last elements of the string, list or tuple
	Arr[-1] means the last element of array Arr[]
Ex:	arr = [1, 2, 3, 4, 5, 6]
	#get the last element
	print(arr[-1]) #output 6
	#get the second last element
	print(arr[-2]) #output 5

4.What is the use of help() function?
	help() function in Python is used to display the documentation of modules, classes, functions, keywords, etc. 
	If no parameter is passed to the help() function, then an interactive help utility is launched on the console

5.What is PYTHONPATH in Python?
	PYTHONPATH is an environment variable which you can set to add additional directories where Python will look for modules and packages. 
	This is especially useful in maintaining Python libraries that you do not wish to install in the global default location

6.What is lambda in Python? Why is it used?
lambda:
	In Python, anonymous(nameless) function means that a function is without a name. 
	As we already know that def keyword is used to define the normal functions and the 
	lambda keyword is used to create anonymous functions. 
	we use lambda functions when you need a small function for a short time
	lambda functions are syntactically restricted to a single expression.
	lambda functions used in map(),reduce(),filter() 
	It has the following syntax:

		lambda arguments : expression

Ex:	sum_twoNum = lambda num1, num2 : num1 + num2
	
	g = lambda x: x*x*x
	print(g(7)) o/p:343

Ex:	def myWrapper(n):
 		return lambda a : a * n
	mulFive = myWrapper(5)
	print(mulFive(2))    # output => 10

7.what are the list & dict & set comprehensions?
	Comprehensions in Python provide us with a short and concise way to construct new sequences (such as lists, set, dictionary etc.) 
	using sequences which have been already defined.
 
	Python supports the following 4 types of comprehensions:
		List Comprehensions
		Dictionary Comprehensions
		Set Comprehensions
		Generator Comprehensions
8. Logging Module?

-- Logging is the process of tracking work happen when some software runs	
-- It is for software developing, debugging and running
-- If we don't have log record & if data is lost it takes time to detect the issue
-- If we have log file record if something goes wrong, we can find the issue

-- Why Printing is not a good option?
	--Some developers used to printing the statements to validate if the statements are executed correctly or not. 
	-- It may solve your issues for simple scripts but for complex scripts, printing approach will fail
	
-- built-in levels of log message:
    Debug : This is used for Detail information, whenever required to diagnoise problems.
	Info : These are used to Confirm that things are working as expected
	Warning : It gives an indication if something unexpected happened, whether there is any problem in future
	Error : It tells us about serious problem, if the software is not able to perform some function
	Critical : This tells serious error, indicating that the program itself may be unable to continue running
	
	
	
9. Random Module?

-- Random module is an in-built module of Python which is used to generate random numbers. 
-- This module used to perform random actions such as generating random numbers, print random a value for a list or string, etc

-- Example: import random
			list1 = [1, 2, 3, 4, 5, 6]
			print(random.choice(list1))

				O/P: 
				
-- randrange() in Python:
	A function that generate random numbers from a given range and steps to be included, called randrange() 
	Syntax : random.randrange(start,stop,step)	
				
-- Creating Random Integers:
	random.randint() method is used to generate random integers between the given range.
	Syntax : random.randint(start, end)	
	
-- Creating Random Floats:
	random.random() method is used to generate random integers between 0.0 to 1.
	Syntax: random.random()
		
-- Selecting Random Choice:
	random.choice() function is used to return a random item from a list, tuple, or string.
	Syntax: random.choice(sequence)		
						
-- Shuffling List:
	random.shuffle() method is used to shuffle a sequence (list).
	Syntax: random.shuffle(sequence, function)

10.Exception handling:
	Exception is the base class for all the exceptions in Python.

	Try and Except Statement – Catching Exceptions
		Try and except statements are used to catch and handle exceptions in Python. 
		Statements that can raise exceptions are kept inside the try clause and the statements that handle the exception are written inside except clause.
			Ex:
				a = [1, 2, 3]
				try:
					print (a[1])
					print (a[4])
				except:
					print("An error occured")
				
		
	Catching Specific Exception:
	A try statement can have more than one except clause, to specify handlers for different exceptions. Please note that at most one handler will be executed

			try:
				# statement(s)
			except IndexError:
				# statement(s)
			except ValueError:
				# statement(s)


	Try with Else Clause:
	In Python we can also use the else clause on the try-except block which must be present after all the except clauses. 
	The code enters the else block only if the try clause does not raise an exception.

	Finally Keyword in Python:
	Python provides a keyword finally, which is always executed after the try and except blocks.
	The final block always executes after normal termination of try block or after try block terminates due to some exception

			try:
				# Some Code.... 

			except:
				# optional block
				# Handling of exception (if required)

			else:
				# execute if no exception

			finally:
				# Some code .....(always executed)		



	Raising Exception:
	The raise statement allows the programmer to force a specific exception to occur. The sole argument in raise indicates the exception to be raised.
	This must be either an exception instance or an exception class (a class that derives from Exception).



	Exception handling errors:
	-Attribute errors				Raised id object accessing a member which is not available
	-File not found errors			Raisedif file is not available
	-Index error					Raised if index to sequence is out of bound
	-KeyError						Raised if non-existent key requested for set or dictionary
	-Name error						Raised if non-exixtant identifier used
	-Type error 					Raised when wrong type of parameter is sent to a function
	-Value error					Raised when parameter has invalid value
	-Zero division error			Raised when division is done by zero





11.Regular expressions:
	A Regular Expression (RegEx) is a sequence of characters that defines a search pattern.
	It can detect the presence or absence of a text by matching with a particular pattern, and also can split a pattern into one or more sub-patterns.
	Python provides a re(regular expression) module that supports the use of regex in Python. 
	Its primary function is to offer a search, where it takes a regular expression and a string.
	 Regular expressions may contain
		 -MetaCharacters
		 -Special Sequences
		 -regex module (functions)
		 
		 
	MetaCharacters:
		\(Backslash)	:	It is used to drop the special meaning of character following it
		[](sqare braces):	Sqarebrackets specifies set of charecters you wish to match
		^(Caret)		:	Matches the beginning
		$(Doller) 		:	Matches the end
		.(Period) 		:	Matches any character except newline
		|(Alternation)	:	Means OR (Matches with any of the characters separated by it.
		?(question mark):	Matches zero or one occurrence of the pattern left to it.
		*(star)			:	Matches zero or more occurrences of the pattern left to it.
		+(plus)			:	matches one or more occurrences of the pattern left to it.
		{}(braces)		:	Indicate the number of occurrences of a preceding regex to match.
		()(group)		:	Enclose a group of Regex
		
	Special sequences:
		\A - Matches if the specified characters are at the start of a string.
		\b - Matches if the specified characters are at the beginning or end of a word.
		\B - Opposite of \b. Matches if the specified characters are not at the beginning or end of a word.
		\d - Matches any decimal digit. Equivalent to [0-9]
		\D - Matches any non-decimal digit. Equivalent to [^0-9]
		\s - Matches where a string contains any whitespace character. Equivalent to [ \t\n\r\f\v].
		\S - Matches where a string contains any non-whitespace character. Equivalent to [^ \t\n\r\f\v].
		\w - Matches any alphanumeric character (digits and alphabets). Equivalent to [a-zA-Z0-9_]. By the way, underscore _ is also considered an alphanumeric character.
		\W - Matches any non-alphanumeric character. Equivalent to [^a-zA-Z0-9_]
		\Z - Matches if the specified characters are at the end of a string.
		
	regex module:
		re.findall()	The re.findall() method returns a list of strings containing all matches.
		re.split()		The re.split method splits the string where there is a match and returns a list of strings where the splits have occurred.
		re.sub()		The method returns a string where matched occurrences are replaced with the content of replace variable.
		re.subn()		The re.subn() is similar to re.sub() except it returns a tuple of 2 items containing the new string and the number of substitutions made.
		re.search()		The re.search() method takes two arguments: a pattern and a string. The method looks for the first location where the RegEx pattern produces a match with the string.
		re.escape() 	The re.escape return string with all non-alphanumerics backslashed, this is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it.


	